@using GanttComponents.Models
@using GanttComponents.Services
@inject IUniversalLogger Logger
@inject IGanttI18N I18N
@inject DateFormatHelper DateFormatter
@implements IDisposable

<div class="timeline-container" style="--header-month-height: @(HeaderMonthHeight)px; --header-day-height: @(HeaderDayHeight)px;">
    <div class="timeline-scroll-container" @onscroll="OnScroll">
        <div class="timeline-header">
            @{
                // Use the new preset template system for predictable, testable header behavior
                var headerConfig = TimelineHeaderAdapter.GetHeaderConfigurationFromTemplate(ZoomLevel, Logger);
                var timeSpanDays = (EndDate - StartDate).Days + 1;
                var shouldCollapse = TimelineHeaderAdapter.ShouldCollapseHeaders(headerConfig, EffectiveDayWidth, timeSpanDays);
            }
            
            @if (headerConfig.ShowPrimary && !shouldCollapse)
            {
                <div class="timeline-header-primary">
                    @{
                        var primaryStart = TimelineHeaderAdapter.GetPeriodStart(StartDate, headerConfig.PrimaryUnit, Logger);
                        var increment = TimelineHeaderAdapter.GetDateIncrement(headerConfig.PrimaryUnit);
                        var current = primaryStart;
                        
                        // Debug logging for header generation
                        Logger?.LogDebugInfo($"HEADER DEBUG: StartDate: {StartDate:yyyy-MM-dd (ddd)}, PrimaryUnit: {headerConfig.PrimaryUnit}, PrimaryStart: {primaryStart:yyyy-MM-dd (ddd)}");
                    }
                    
                    @while (current <= EndDate)
                    {
                        var periodWidth = TimelineHeaderAdapter.GetPeriodWidth(current, headerConfig.PrimaryUnit, EffectiveDayWidth);
                        var nextPeriod = increment(current);
                        
                        // Debug logging for each header cell
                        Logger?.LogDebugInfo($"HEADER CELL DEBUG: Current: {current:yyyy-MM-dd (ddd)}, Format: {headerConfig.PrimaryFormat}, Width: {periodWidth}px");
                        
                        // Adjust width if period extends beyond timeline
                        if (nextPeriod > EndDate.AddDays(1))
                        {
                            var visibleDays = (EndDate.AddDays(1) - current).Days;
                            periodWidth = visibleDays * EffectiveDayWidth;
                        }
                        
                        // Skip if period starts after timeline end
                        if (current > EndDate)
                        {
                            break;
                        }
                        
                        <div class="timeline-primary-unit" style="width: @(periodWidth)px;">
                            @DateFormatter.FormatTimelineHeader(current, headerConfig.PrimaryFormat)
                        </div>
                        
                        current = nextPeriod;
                    }
                </div>
            }
            
            <div class="timeline-header-secondary">
                @{
                    var secondaryStart = TimelineHeaderAdapter.GetPeriodStart(StartDate, headerConfig.SecondaryUnit, Logger);
                    var secondaryIncrement = TimelineHeaderAdapter.GetDateIncrement(headerConfig.SecondaryUnit);
                    var secondaryCurrent = secondaryStart;
                }
                
                @while (secondaryCurrent <= EndDate)
                {
                    var secondaryWidth = TimelineHeaderAdapter.GetPeriodWidth(secondaryCurrent, headerConfig.SecondaryUnit, EffectiveDayWidth);
                    var nextSecondary = secondaryIncrement(secondaryCurrent);
                    
                    // Adjust width if period extends beyond timeline
                    if (nextSecondary > EndDate.AddDays(1))
                    {
                        var visibleDays = (EndDate.AddDays(1) - secondaryCurrent).Days;
                        secondaryWidth = visibleDays * EffectiveDayWidth;
                    }
                    
                    // Skip if period starts after timeline end
                    if (secondaryCurrent > EndDate)
                    {
                        break;
                    }
                    
                    <div class="timeline-secondary-unit" style="width: @(secondaryWidth)px;">
                        @DateFormatter.FormatTimelineHeader(secondaryCurrent, headerConfig.SecondaryFormat)
                    </div>
                    
                    secondaryCurrent = nextSecondary;
                }
            </div>
        </div>
        
        <div class="timeline-body">
        <svg class="timeline-svg" width="@(TotalWidth)" height="@(TotalHeight)">
            <!-- Grid lines for days -->
            @for (var day = StartDate; day <= EndDate; day = day.AddDays(1))
            {
                var x = DayToPixel(day);
                <line x1="@x" y1="0" x2="@x" y2="@TotalHeight" 
                      class="timeline-grid-line" />
            }
            
            <!-- Task bars -->
            @if (Tasks != null)
            {
                @for (int i = 0; i < Tasks.Count; i++)
                {
                    var task = Tasks[i];
                    var y = i * RowHeight;
                    var x = DayToPixel(task.StartDate);
                    var width = CalculateTaskWidth(task);
                    var rowIndex = i;
                    
                    <!-- Task background row -->
                    <rect x="0" y="@y" width="@TotalWidth" height="@RowHeight"
                          class="timeline-row @(SelectedTaskId == task.Id ? "selected" : "") @(HoveredTaskId == task.Id ? "hovered" : "")"
                          data-task-id="@task.Id"
                          @onclick="() => SelectTask(task.Id)"
                          @onmouseenter="() => HoverTask(task.Id)"
                          @onmouseleave="() => HoverTask(null)" />
                    
                    <!-- Task bar -->
                    <rect x="@x" y="@(y + TaskBarMargin)" 
                          width="@width" height="@(TaskBarHeight)"
                          class="timeline-task-bar"
                          data-task-id="@task.Id"
                          @onclick="() => SelectTask(task.Id)"
                          @onmouseenter="() => HoverTask(task.Id)"
                          @onmouseleave="() => HoverTask(null)">
                        <title>@GetTaskTooltip(task)</title>
                    </rect>
                    
                    <!-- Task label (WBS Code) - TODO: Add text labels -->
                    @* <svg:text x="@(x + 4)" y="@(y + RowHeight/2 + 4)" class="timeline-task-label">@task.WbsCode</svg:text> *@
                }
            }
        </svg>
        </div>
    </div>
</div>

@code {
    [Parameter] public List<GanttTask>? Tasks { get; set; }
    [Parameter] public EventCallback<int> OnTaskSelected { get; set; }
    [Parameter] public EventCallback<EventArgs> OnScrollChanged { get; set; }
    [Parameter] public int? SelectedTaskId { get; set; }
    [Parameter] public int RowHeight { get; set; } = 32; // Default row height for alignment
    [Parameter] public int HeaderMonthHeight { get; set; } = 32; // Month row height
    [Parameter] public int HeaderDayHeight { get; set; } = 24; // Day row height
    [Parameter] public EventCallback<int?> OnTaskHovered { get; set; }
    [Parameter] public int? HoveredTaskId { get; set; }
    
    // Zoom parameters - maintain backward compatibility with current 40px day width
    [Parameter] public TimelineZoomLevel ZoomLevel { get; set; } = TimelineZoomLevel.MonthWeek;
    [Parameter] public double ZoomFactor { get; set; } = 1.6; // 25px * 1.6 = 40px (maintains current behavior)
    
    // Zoom state change events
    [Parameter] public EventCallback<TimelineZoomLevel> OnZoomLevelChanged { get; set; }
    [Parameter] public EventCallback<double> OnZoomFactorChanged { get; set; }
    
    // Timeline configuration
    // Legacy constant maintained for reference - replaced by EffectiveDayWidth property
    private const int LegacyDayWidth = 40; // Was: 40px per day (fixed scale)
    private const int TaskBarHeight = 20;
    private const int TaskBarMargin = 6; // Center task bar in row
    
    // Dynamic day width based on zoom level and factor
    private double EffectiveDayWidth
    {
        get
        {
            var config = TimelineZoomService.GetConfiguration(ZoomLevel);
            return config.GetEffectiveDayWidth(ZoomFactor);
        }
    }
    
    // Calculated total header height
    private int TotalHeaderHeight => HeaderMonthHeight + HeaderDayHeight;
    
    // Timeline date range
    private DateTime StartDate { get; set; }
    private DateTime EndDate { get; set; }
    private int TotalWidth { get; set; }
    private int TotalHeight { get; set; }

    protected override void OnInitialized()
    {
        Logger.LogComponentLifecycle("TimelineView", "OnInitialized", new { TaskCount = Tasks?.Count ?? 0 });
        
        // Subscribe to language changes
        I18N.LanguageChanged += OnLanguageChanged;
        
        CalculateTimelineRange();
    }

    protected override void OnParametersSet()
    {
        CalculateTimelineRange();
        StateHasChanged();
    }

    private void CalculateTimelineRange()
    {
        DateTime taskStartDate, taskEndDate;
        
        if (Tasks == null || !Tasks.Any())
        {
            // Default range if no tasks
            taskStartDate = DateTime.UtcNow.Date.AddDays(-30);
            taskEndDate = DateTime.UtcNow.Date.AddDays(90);
        }
        else
        {
            taskStartDate = Tasks.Min(t => t.StartDate).Date.AddDays(-7);
            taskEndDate = Tasks.Max(t => t.EndDate).Date.AddDays(7);
        }
        
        // Get header configuration to align timeline boundaries with header periods
        var headerConfig = TimelineHeaderAdapter.GetHeaderConfigurationFromTemplate(ZoomLevel, Logger);
        
        // Align StartDate with primary period boundary (e.g., week start for WeekDay modes)
        StartDate = TimelineHeaderAdapter.GetPeriodStart(taskStartDate, headerConfig.PrimaryUnit, Logger);
        
        // Align EndDate with primary period boundary
        var endPeriodStart = TimelineHeaderAdapter.GetPeriodStart(taskEndDate, headerConfig.PrimaryUnit, Logger);
        var increment = TimelineHeaderAdapter.GetDateIncrement(headerConfig.PrimaryUnit);
        EndDate = increment(endPeriodStart).AddDays(-1); // End of the period
        
        // Debug logging for timeline range calculation
        Logger?.LogDebugInfo($"TIMELINE RANGE DEBUG: Original TaskStart: {taskStartDate:yyyy-MM-dd (ddd)}, TaskEnd: {taskEndDate:yyyy-MM-dd (ddd)}");
        Logger?.LogDebugInfo($"TIMELINE RANGE DEBUG: Aligned StartDate: {StartDate:yyyy-MM-dd (ddd)}, EndDate: {EndDate:yyyy-MM-dd (ddd)}");
        Logger?.LogDebugInfo($"TIMELINE RANGE DEBUG: PrimaryUnit: {headerConfig.PrimaryUnit}, Alignment ensures header boundaries match timeline coordinates");
        
        if (Tasks != null && Tasks.Any())
        {
            var minTaskStart = Tasks.Min(t => t.StartDate);
            var maxTaskEnd = Tasks.Max(t => t.EndDate);
            Logger?.LogDebugInfo($"TASK RANGE DEBUG: Min StartDate: {minTaskStart:yyyy-MM-dd (ddd)}, Max EndDate: {maxTaskEnd:yyyy-MM-dd (ddd)}");
        }
        
        var totalDays = (EndDate - StartDate).Days + 1;
        TotalWidth = (int)(totalDays * EffectiveDayWidth);
        TotalHeight = (Tasks?.Count ?? 0) * RowHeight;
    }

    private double DayToPixel(DateTime date)
    {
        var days = (date.Date - StartDate).TotalDays;
        return days * EffectiveDayWidth;
    }

    private double CalculateTaskWidth(GanttTask task)
    {
        var duration = (task.EndDate.Date - task.StartDate.Date).TotalDays + 1;
        return duration * EffectiveDayWidth;
    }

    private int GetMonthWidth(DateTime month)
    {
        var daysInMonth = DateTime.DaysInMonth(month.Year, month.Month);
        return (int)(daysInMonth * EffectiveDayWidth);
    }

    private async Task SelectTask(int taskId)
    {
        SelectedTaskId = taskId;
        Logger.LogUserAction("TimelineView_TaskSelected", new { TaskId = taskId });
        
        if (OnTaskSelected.HasDelegate)
        {
            await OnTaskSelected.InvokeAsync(taskId);
        }
        
        StateHasChanged();
    }

    private async Task HoverTask(int? taskId)
    {
        if (HoveredTaskId != taskId)
        {
            HoveredTaskId = taskId;
            await OnTaskHovered.InvokeAsync(taskId);
        }
    }

    private async Task OnScroll(EventArgs e)
    {
        if (OnScrollChanged.HasDelegate)
        {
            await OnScrollChanged.InvokeAsync(e);
        }
    }

    private void OnLanguageChanged()
    {
        try
        {
            InvokeAsync(StateHasChanged);
        }
        catch (ObjectDisposedException)
        {
            // Component has been disposed, ignore language change
        }
        catch (InvalidOperationException)
        {
            // Component is not in a valid state for updates, ignore
        }
    }

    // Zoom control methods
    public async Task SetZoomLevelAsync(TimelineZoomLevel newZoomLevel)
    {
        if (ZoomLevel != newZoomLevel)
        {
            ZoomLevel = newZoomLevel;
            CalculateTimelineRange(); // Recalculate dimensions
            Logger.LogUserAction("TimelineView_ZoomLevelChanged", new { OldLevel = ZoomLevel, NewLevel = newZoomLevel });
            
            if (OnZoomLevelChanged.HasDelegate)
            {
                await OnZoomLevelChanged.InvokeAsync(newZoomLevel);
            }
            
            StateHasChanged();
        }
    }

    public async Task SetZoomFactorAsync(double newZoomFactor)
    {
        // Clamp zoom factor to reasonable bounds (0.5x to 3.0x)
        var clampedFactor = Math.Max(0.5, Math.Min(3.0, newZoomFactor));
        
        if (Math.Abs(ZoomFactor - clampedFactor) > 0.01) // Avoid tiny changes
        {
            var oldFactor = ZoomFactor;
            ZoomFactor = clampedFactor;
            CalculateTimelineRange(); // Recalculate dimensions
            Logger.LogUserAction("TimelineView_ZoomFactorChanged", new { OldFactor = oldFactor, NewFactor = clampedFactor });
            
            if (OnZoomFactorChanged.HasDelegate)
            {
                await OnZoomFactorChanged.InvokeAsync(clampedFactor);
            }
            
            StateHasChanged();
        }
    }

    public async Task ZoomInAsync()
    {
        var newFactor = ZoomFactor * 1.2; // 20% increase
        await SetZoomFactorAsync(newFactor);
    }

    public async Task ZoomOutAsync()
    {
        var newFactor = ZoomFactor / 1.2; // 20% decrease
        await SetZoomFactorAsync(newFactor);
    }

    public async Task ResetZoomAsync()
    {
        await SetZoomFactorAsync(1.0); // Reset to base factor
    }

    // Read-only properties for current zoom state
    public double CurrentEffectiveDayWidth => EffectiveDayWidth;
    public string CurrentZoomDescription => $"{ZoomLevel} @ {ZoomFactor:F1}x";

    public void Dispose()
    {
        try
        {
            if (I18N != null)
            {
                I18N.LanguageChanged -= OnLanguageChanged;
            }
        }
        catch (ObjectDisposedException)
        {
            // Ignore disposal exceptions during cleanup
        }
    }

    private string GetTaskTooltip(GanttTask task)
    {
        if (task == null) return string.Empty;
        
        try
        {
            // Debug logging for task tooltip dates
            Logger?.LogDebugInfo($"TOOLTIP DEBUG: Task '{task.Name}' StartDate: {task.StartDate:yyyy-MM-dd (ddd)}, EndDate: {task.EndDate:yyyy-MM-dd (ddd)}");
            
            return $"{task.Name} ({task.StartDate:MM/dd/yyyy} - {task.EndDate:MM/dd/yyyy})";
        }
        catch
        {
            // Fallback if formatting fails
            return task.Name ?? "Task";
        }
    }
}

<style>
    .timeline-container {
        display: flex;
        flex-direction: column;
        height: 100%;
        border: 1px solid var(--gantt-outline, #e0e0e0);
        background: var(--gantt-surface, #ffffff);
    }

    .timeline-scroll-container {
        flex: 1;
        overflow: auto;
        position: relative;
    }

    .timeline-header {
        position: sticky;
        top: 0;
        z-index: 10;
        background: var(--gantt-surface, #ffffff);
        border-bottom: 1px solid var(--gantt-outline, #e0e0e0);
        min-width: fit-content;
    }

    /* Zoom-adaptive primary header row (quarters, years, decades) */
    .timeline-header-primary {
        display: flex;
        height: var(--header-month-height);
        border-bottom: 1px solid var(--gantt-outline, #e0e0e0);
    }

    .timeline-primary-unit {
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 500;
        font-family: var(--gantt-monospace-font, 'Consolas', 'Monaco', 'Courier New', monospace);
        border-right: 1px solid var(--gantt-outline, #e0e0e0);
        background: var(--gantt-surface-variant, #f5f5f5);
        box-sizing: border-box;
        margin: 0;
        padding: 0;
        flex-shrink: 0;
        min-width: 0; /* Allow text overflow handling */
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
    }

    /* Zoom-adaptive secondary header row (months, quarters, years) */
    .timeline-header-secondary {
        display: flex;
        height: var(--header-day-height);
    }

    .timeline-secondary-unit {
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
        font-family: var(--gantt-monospace-font, 'Consolas', 'Monaco', 'Courier New', monospace);
        border-right: 1px solid var(--gantt-outline, #e0e0e0);
        background: var(--gantt-surface, #ffffff);
        box-sizing: border-box;
        margin: 0;
        padding: 0;
        flex-shrink: 0;
        min-width: 0; /* Allow text overflow handling */
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
    }

    /* Legacy classes for backward compatibility - deprecated */
    .timeline-header-months {
        display: flex;
        height: var(--header-month-height);
        border-bottom: 1px solid var(--gantt-outline, #e0e0e0);
    }

    .timeline-month {
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 500;
        font-family: var(--gantt-monospace-font, 'Consolas', 'Monaco', 'Courier New', monospace);
        border-right: 1px solid var(--gantt-outline, #e0e0e0);
        background: var(--gantt-surface-variant, #f5f5f5);
        box-sizing: border-box;
        margin: 0;
        padding: 0;
        flex-shrink: 0;
    }

    .timeline-header-days {
        display: flex;
        height: var(--header-day-height);
    }

    .timeline-day {
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
        border-right: 1px solid var(--gantt-outline, #e0e0e0);
        background: var(--gantt-surface, #ffffff);
        box-sizing: border-box;
        margin: 0;
        padding: 0;
        flex-shrink: 0;
    }

    .timeline-body {
        position: relative;
        min-width: fit-content;
    }

    .timeline-svg {
        display: block;
    }

    .timeline-grid-line {
        stroke: var(--gantt-outline-variant, #f0f0f0);
        stroke-width: 1;
    }

    .timeline-row {
        fill: transparent;
        cursor: pointer;
    }

    .timeline-row:hover {
        fill: var(--gantt-state-hover, rgba(25, 118, 210, 0.04));
    }

    .timeline-row.hovered {
        fill: var(--gantt-state-hovered, rgba(33, 150, 243, 0.06));
    }

    .timeline-row.selected {
        fill: var(--gantt-state-selected, rgba(25, 118, 210, 0.08));
    }

    .timeline-task-bar {
        fill: var(--gantt-primary, #1976d2);
        rx: 2;
        cursor: pointer;
    }

    .timeline-task-bar:hover {
        fill: var(--gantt-primary-dark, #1565c0);
    }

    .timeline-task-label {
        fill: var(--gantt-on-surface, #000000);
        font-size: 12px;
        font-family: var(--gantt-font-family, system-ui);
        pointer-events: none;
        user-select: none;
    }
</style>
